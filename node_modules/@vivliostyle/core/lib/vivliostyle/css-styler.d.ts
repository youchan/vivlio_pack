import * as Css from "./css";
import * as CssCascade from "./css-cascade";
import * as CssValidator from "./css-validator";
import * as Exprs from "./exprs";
import * as Vtree from "./vtree";
import { CssStyler, XmlDoc } from "./types";
export declare class SlipRange {
    endStuckFixed: number;
    endFixed: number;
    endSlipped: number;
    constructor(endStuckFixed: any, endFixed: any, endSlipped: any);
}
/**
 * Maps all ints in a range ("fixed") to ints with slippage ("slipped")
 */
export declare class SlipMap {
    map: SlipRange[];
    getMaxFixed(): number;
    getMaxSlipped(): number;
    addStuckRange(endFixed: number): void;
    addSlippedRange(endFixed: number): void;
    slippedByFixed(fixed: number): number;
    /**
     * Smallest fixed for a given slipped.
     */
    fixedBySlipped(slipped: number): number;
}
export interface FlowListener {
    encounteredFlowChunk(flowChunk: Vtree.FlowChunk, flow: Vtree.Flow): void;
}
export interface AbstractStyler extends CssStyler.AbstractStyler {
}
/**
 * Represent a box generated by a (pseudo)element. When constructed, a box
 * corresponding to `::before` pseudoelement is also constructed and stored in
 * `beforeBox` property, whereas one corresponding `::after` pseudoelement is
 * not constructed and `afterBox` property is `null`. `afterBox` is constructed
 * by `buildAfterPseudoElementBox` method.
 * @param style Cascaded style values for the box.
 * @param offset The start offset of the box. It coincides with the start offset
 *     of the element if the box is generated by the element or the `::before`
 *     pseudoelement. When the box corresponds to the `::after` pseudoelement,
 *     the offset is just after the content before the `::after` pseudoelement.
 * @param isRoot True if the box is generated by the root element (not
 *     pseudoelement).
 * @param flowChunk FlowChunk to which the box belongs to.
 * @param atBlockStart True if the box is right after the block start edge.
 * @param atFlowStart True if the box is right after the flow start.
 * @param isParentBoxDisplayed True if the parent box has a displayed box.
 */
export declare class Box {
    readonly context: Exprs.Context;
    readonly style: CssCascade.ElementStyle;
    readonly offset: number;
    readonly isRoot: boolean;
    readonly flowChunk: Vtree.FlowChunk;
    readonly atBlockStart: boolean;
    readonly atFlowStart: boolean;
    readonly isParentBoxDisplayed: boolean;
    flowName: string;
    isBlockValue: boolean | null;
    hasBoxValue: boolean | null;
    styleValues: {
        [key: string]: Css.Val;
    };
    beforeBox: Box;
    afterBox: Box;
    breakBefore: string | null;
    constructor(context: Exprs.Context, style: CssCascade.ElementStyle, offset: number, isRoot: boolean, flowChunk: Vtree.FlowChunk, atBlockStart: boolean, atFlowStart: boolean, isParentBoxDisplayed: boolean);
    /**
     * Build a box corresponding to `::after` pseudoelement and stores it in
     * `afterBox` property.
     * @param offset The start offset of the `::after` pseudoelement box, which is
     *     just after the content before the `::after` pseudoelement.
     * @param atBlockStart True if the box is right after the block start edge.
     * @param atFlowStart True if the box is right after the flow start.
     */
    buildAfterPseudoElementBox(offset: number, atBlockStart: boolean, atFlowStart: boolean): void;
    styleValue(name: string, defaultValue?: Css.Val): Css.Val | null;
    displayValue(): Css.Val;
    isBlock(): boolean;
    hasBox(): boolean;
    getBreakValue(edge: string): string | null;
}
/**
 * Manages boxes generated by elements as a stack.
 */
export declare class BoxStack {
    readonly context: Exprs.Context;
    stack: Box[];
    atBlockStart: boolean;
    atFlowStart: boolean;
    atStartStack: {
        atBlockStart: boolean;
        atFlowStart: boolean;
    }[];
    constructor(context: Exprs.Context);
    /**
     * Returns if the stack is empty.
     */
    empty(): boolean;
    /**
     * Returns the last box in the stack.
     */
    lastBox(): Box | undefined;
    /**
     * Returns the flow name of the last box in the stack.
     */
    lastFlowName(): string | null;
    /**
     * Returns if the last box in the stack is displayed.
     */
    isCurrentBoxDisplayed(): boolean;
    /**
     * Create a new box and push it to the stack.
     * @param style Cascaded style values for the box.
     * @param offset The start offset of the box.
     * @param isRoot True if the box is generated by the root element
     * @param newFlowChunk Specify if the element is a flow element (i.e. the
     *     element is specified a new `flow-into` value)
     */
    push(style: CssCascade.ElementStyle, offset: number, isRoot: boolean, newFlowChunk?: Vtree.FlowChunk): Box;
    encounteredTextNode(node: Node): void;
    /**
     * Pop the last box.
     */
    pop(offset: number): Box;
    /**
     * Find the start offset of the nearest block start edge to which the
     * `break-before` value of the box should be propagated. This method can be
     * called when after pushing the box into the stack or after popping the box
     * out of the stack.
     */
    nearestBlockStartOffset(box: Box): number;
}
export declare class Styler implements AbstractStyler {
    readonly xmldoc: XmlDoc.XMLDocHolder;
    readonly scope: Exprs.LexicalScope;
    readonly context: Exprs.Context;
    readonly primaryFlows: {
        [key: string]: boolean;
    };
    readonly validatorSet: CssValidator.ValidatorSet;
    readonly counterListener: CssCascade.CounterListener;
    root: Element;
    cascadeHolder: CssCascade.Cascade;
    last: Node;
    rootStyle: CssCascade.ElementStyle;
    styleMap: {
        [key: string]: CssCascade.ElementStyle;
    };
    flows: {
        [key: string]: Vtree.Flow;
    };
    flowChunks: Vtree.FlowChunk[];
    flowListener: FlowListener;
    flowToReach: string | null;
    idToReach: string | null;
    cascade: CssCascade.CascadeInstance;
    offsetMap: SlipMap;
    primary: boolean;
    primaryStack: boolean[];
    rootBackgroundAssigned: boolean;
    rootLayoutAssigned: boolean;
    lastOffset: number;
    breakBeforeValues: {
        [key: number]: string | null;
    };
    boxStack: BoxStack;
    bodyReached: boolean;
    constructor(xmldoc: XmlDoc.XMLDocHolder, cascade: CssCascade.Cascade, scope: Exprs.LexicalScope, context: Exprs.Context, primaryFlows: {
        [key: string]: boolean;
    }, validatorSet: CssValidator.ValidatorSet, counterListener: CssCascade.CounterListener, counterResolver: CssCascade.CounterResolver);
    hasProp(style: CssCascade.ElementStyle, map: CssValidator.ValueMap, name: string): boolean;
    transferPropsToRoot(srcStyle: CssCascade.ElementStyle, map: CssValidator.ValueMap): void;
    /**
     * Transfer properties that should be applied on the container (partition)
     * level to this.rootStyle.
     * @param elemStyle (source) element style
     */
    postprocessTopStyle(elemStyle: CssCascade.ElementStyle, isBody: boolean): void;
    getTopContainerStyle(): CssCascade.ElementStyle;
    getAttrStyle(elem: Element): CssCascade.ElementStyle;
    /**
     * @return currently reached offset
     */
    getReachedOffset(): number;
    /**
     * Replay flow elements that were encountered since the given offset
     */
    replayFlowElementsFromOffset(offset: number): void;
    resetFlowChunkStream(flowListener: FlowListener): void;
    styleUntilFlowIsReached(flowName: string): void;
    styleUntilIdIsReached(id: string): void;
    private encounteredFlowElement;
    registerForcedBreakOffset(breakValue: string | null, offset: number, flowName: string): void;
    /**
     * @param startOffset current position in the document
     * @param lookup lookup window size for the next page
     * @return lookup offset in the document for the next page
     */
    styleUntil(startOffset: number, lookup: number): number;
    /** @override */
    getStyle(element: Element, deep: boolean): CssCascade.ElementStyle;
    /** @override */
    processContent(element: Element, styles: {
        [key: string]: Css.Val;
    }, viewNode: Node): void;
}
export declare const columnProps: string[];
